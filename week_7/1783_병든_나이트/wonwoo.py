# 시간: 36ms, 메모리: 32544KB

# N = 세로 길이, M = 가로 길이
# 접근
    # N이 1이면 움직이지 못 함 그냥 1개
    # N이 2이면 1칸 위로. 1칸 아래로 두 경우밖에 없음
        # 이동 횟수가 4번까지는 마음대로지만 5번부터는 이동 방법을 다 사용 -> 최대 이동은 4번
        # min(4, 이동횟수)
        # 이동 횟수는 M이 홀수일 때마다 1씩 증가
        # 이동 횟수 : M + 1 // 2
    # N이 3이면 모든 경우의 수 다 가능
        # 그럼 M이 뭔지에 따라 또 달라짐
        # M <= 4 이면 
            # min(4, 이동횟수)
            # 이 때 이동 횟수는 M
        # M 이 5,6 일 경우
            # 4번으로 고정 -> count를 4번 사용하고 5번째 사용 할 때, 중복이 되기 때문
        # M > 6
            # 6번째까지는 고정으로 4번이고, 
            # 그 이후부터는 (위로 2칸 오른쪽으로 1칸), (아래로 2칸 오른쪽으로 1칸) 움직이는 경우의 수 1번씩 추가해주면 됨
            # 이 때때 이동 횟수는 (M - 2)
import sys
input = sys.stdin.readline
N,M = map(int,input().split())

if N == 1 :
    count = 1
elif N == 2 :
    count = min(4, ((M + 1) // 2))
elif M <= 4:
    count = min(4, M)
elif M in [5, 6]:
    count = 4 
else :
    count = M - 2

print(count)